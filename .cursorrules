# AI SaaS Builder Platform - Cursor Rules

All AI behavior rules and code generation standards for this project.

---

## ğŸŒ GLOBAL RULES

### Technology Stack

- **Language**: TypeScript (mandatory)
- **Frontend**: Next.js 15 (App Router)
- **Backend**: NestJS 10+
- **Database**: PostgreSQL + TypeORM
- **Styling**: TailwindCSS + Shadcn/UI
- **State Management**: Zustand / TanStack Query
- **Package Manager**: pnpm
- **Monorepo**: Turbo 2.0+
  - âš ï¸ Since Turbo 2.0, use `tasks` instead of `pipeline` in `turbo.json`
  - âœ… AI must always generate Turbo config with `tasks` field

### Code Standards

- **Formatter**: Biome (2 spaces, semicolons, single quotes)
- **File Naming**: kebab-case
- **Component/Class**: PascalCase
- **Variables/Functions**: camelCase
- **Import Path**: `@/` prefix for absolute imports
- **Import Order**: React â†’ Libraries â†’ Local modules

### Architecture

```
apps/
  frontend/
  api/
packages/
  ui/
  database/
  core/
```

### AI Behavior Rules

1. âœ… Always check existing conventions
2. âœ… Auto-create folder structure for new modules
3. âœ… Generate minimal and clean code
4. âœ… Never copy config/env variables
5. âœ… Generate TypeScript strict mode compliant code
6. âœ… Generate lint and type error-free code
7. âŒ Do not use deprecated APIs
8. âŒ Do not use legacy syntax
9. âŒ Do not use class-based React components

### Security

- âŒ Never commit `.env`, secrets, private keys
- âœ… Sanitize all user inputs
- âœ… HTTPS and CORS configuration mandatory
- âœ… Use try/catch in async operations
- âœ… Implement global error handling

### Testing

- **Unit**: Jest
- **E2E**: Supertest / Playwright
- Each new module must include at least 1 integration test
- Use mocks for external APIs

---

## ğŸ—„ï¸ DATABASE RULES

### Core Principles

- **Engine**: PostgreSQL 15+
- **ORM**: TypeORM
- **Design**: Normalized, explicit, consistent
- **Dependency Flow**: Domain â†’ Application â†’ Infrastructure

### Entity Rules

#### File and Naming

- **Location**: `src/modules/<feature>/<feature>.entity.ts`
- **Decorator**: `@Entity({ name: '<table_name>' })`
- **Table Name**: snake_case plural (e.g., `users`, `user_roles`)
- **Class Name**: PascalCase singular (e.g., `User`, `UserRole`)
- **Columns**: snake_case + explicit types

#### Base Entity Required Fields

```typescript
@PrimaryGeneratedColumn('uuid')
id: string;

@CreateDateColumn({ type: 'timestamp with time zone' })
createdAt: Date;

@UpdateDateColumn({ type: 'timestamp with time zone' })
updatedAt: Date;

@DeleteDateColumn({ type: 'timestamp with time zone', nullable: true })
deletedAt?: Date | null;
```

### Column Types

| Type        | Example                                                 | Rule                                    |
| ----------- | ------------------------------------------------------- | --------------------------------------- |
| Primary Key | `id: string`                                            | Always uuid                             |
| Foreign Key | `userId: string`                                        | @ManyToOne + @JoinColumn                |
| Enum        | `@Column({ type: 'enum', enum: UserRole })`             | TS enums with string values             |
| JSON        | `@Column({ type: 'jsonb', nullable: true })`            | Only for flexible metadata              |
| Boolean     | `@Column({ default: false })`                           | Always default false                    |
| Numeric     | `@Column({ type: 'numeric', precision: 12, scale: 2 })` | For money/decimal                       |
| Unique      | `@Index({ unique: true })`                              | Never rely solely on validation layer   |

### Relations

```typescript
// OneToMany
@OneToMany(() => Post, (post) => post.user, { cascade: ['insert', 'update'] })
posts: Post[];

// ManyToOne
@ManyToOne(() => User, (user) => user.posts)
@JoinColumn({ name: 'user_id' })
user: User;
```

**Rules**:

- âœ… Define both sides explicitly
- âœ… Set cascade rules consciously
- âŒ Do not use cascade delete in production (prefer soft delete)
- âœ… Specify `onDelete` behavior explicitly (RESTRICT, SET NULL, etc.)
- âœ… Use dedicated entity for many-to-many (not auto-generated)

### Index and Constraints

```typescript
@Index('idx_<table>_<column>', ['column'])
```

- âœ… Index foreign keys and frequently queried fields
- âœ… Unique constraint for natural keys (email, code)
- âš ï¸ Max 3-5 indexes per table (avoid over-indexing)

### Migration Rules

```bash
npm run typeorm migration:generate
npm run typeorm migration:run
```

**Location**: `src/core/database/migrations/`

**Requirements**:

- âœ… Descriptive name (e.g., `AddUserTable1701029916000.ts`)
- âœ… Reversible `up()` and `down()` methods
- âŒ AI never changes entity schema without migration
- âš ï¸ Warn if migration is missing

### Transaction (UnitOfWork)

```typescript
await this.uow.execute(async (manager) => {
  const user = manager.getRepository(User).create(dto);
  await manager.save(user);
});
```

- âœ… All write operations must be in transactions
- âœ… Rollback on error
- âŒ Do not await calls outside transaction scope

### Security

- âœ… Sanitize user-provided data before persisting
- âœ… Hash/encrypt sensitive fields (password, secret, token)
- âœ… Mask PII in logs
- âŒ AI never generates interpolated SQL strings

### AI Generation Behavior

When generating or editing code:

1. âœ… Check existing entity first
2. âœ… Auto-add @Entity() and @Column() decorators
3. âœ… Validate TypeORM imports
4. âœ… Verify entities are registered in module's TypeOrmModule.forFeature()
5. âœ… Check schema consistency â†’ suggest migration if mismatch
6. âŒ Do not generate raw SQL queries unless explicitly requested
7. âš ï¸ Auto-detect and warn:
   - Missing foreign key constraints
   - Unindexed query filters
   - Ambiguous/duplicate field names
8. âœ… Use strict nullability (nullable: false unless required)
9. âœ… Use `TableIndex`, `TableForeignKey` in migration files (not `Index`)

---

## ğŸ”§ BACKEND RULES

### Clean Architecture Layers

```
domain/         # Pure business logic, entities, value objects
application/    # Use-cases, services, ports
infrastructure/ # TypeORM, database, external APIs
interface/      # Controllers, DTOs, HTTP adapters
```

**Dependency Direction**: Inward only

- âŒ No Domain â†’ Framework dependency
- âœ… Entities, Repositories, UseCases are framework-agnostic

### Design Principles

- **SOLID** - Single Responsibility, Open/Closed, Liskov, Interface Segregation, Dependency Inversion
- **DRY** - Don't Repeat Yourself
- **KISS** - Keep It Simple, Stupid
- **YAGNI** - You Aren't Gonna Need It

**Applications**:

- âœ… Abstract repeating code
- âœ… Functions short (â‰¤40 lines), single responsibility
- âŒ Avoid nested conditionals and deeply coupled logic
- âŒ No over-engineering - simplest solid solution wins
- âœ… Use generics, interfaces, DI consistently

### Repository & CRUD Pattern

```typescript
@Injectable()
export class UsersService extends GenericCrudService<User> {
  constructor(
    @InjectRepository(UserRepository) repo: UserRepository,
    private readonly uow: UnitOfWork
  ) {
    super(repo);
  }

  async register(dto: CreateUserDto): Promise<User> {
    return this.uow.execute(async () => {
      const user = await this.repo.createUser(dto);
      return user;
    });
  }
}
```

### TypeScript Strict Mode

```json
{
  "strict": true,
  "noImplicitAny": true,
  "noUncheckedIndexedAccess": true,
  "strictNullChecks": true,
  "exactOptionalPropertyTypes": true
}
```

### ConfigService Type Safety

When using ConfigService with `exactOptionalPropertyTypes: true`:

- âœ… Use non-null assertion in `configService.get()` calls: `configService.get('KEY')!`
- âœ… Or provide default value with generic type: `configService.get<string>('KEY', 'default')`
- âš ï¸ Guarantee required fields with Joi/Zod validation
- âŒ Do not assign `configService.get()` result to types that may be undefined

### Map/Filter Callback Types

Avoid implicit any in array operations:

- âœ… Use explicit types in map callbacks: `items.map((item: Type) => ...)`
- âœ… Manually specify if TypeScript type inference is insufficient
- âŒ Use `(item: ItemType)` instead of `(item)`

### Nullable DTO Mapping

With `exactOptionalPropertyTypes: true`:

- âœ… Use nullish coalescing when mapping Entity to DTO: `entity.field ?? null`
- âœ… **Optional fields in DTOs MUST be in `?: T | undefined` format**
- âœ… **Optional fields in interfaces MUST be specified as `?: T | undefined`**
- âŒ `field?: T` usage is incompatible with `exactOptionalPropertyTypes: true`
- âŒ Do not directly assign `T | null | undefined` type to `T | null` type
- âš ï¸ Zod schemas return `T | undefined` with `.optional()`, define types accordingly

### Biome Rules

- âœ… Code must be Biome-validated before output
- âœ… AI must auto-fix:
  - Add missing imports
  - Remove unused imports/vars
  - Format code
- âœ… Import order: Nest â†’ Third-party â†’ Internal (@/...)
- âŒ No wildcard imports (`import * as`)
- âŒ No default exports

### ğŸ” Security Standards

#### General

- âœ… All secrets and credentials only from ConfigService
- âŒ Never inline or default in code
- âœ… Sanitize all inputs (DTO + ValidationPipe)
- âœ… Escape user values before DB writes
- âœ… Use parameterized queries (TypeORM default)
- âŒ Avoid dynamic SQL or raw queries

#### Web Security

- âœ… Global CORS + allowed origins list
- âœ… HTTPS and secure cookies mandatory
- âœ… Disable X-Powered-By header
- âœ… Apply Helmet middleware
- âœ… Rate-limiting (@nestjs/throttler) for brute-force

#### Data Protection

- âœ… Hash all passwords with Argon2 or bcrypt
- âœ… Encrypt sensitive fields (PII) before persisting
- âŒ Never log secrets or tokens
- âœ… Exclude sensitive fields in DTOs and responses

#### API Security

- âœ… Auth: JWT or OAuth2 via PassportModule
- âœ… Validate roles/permissions with @UseGuards()
- âœ… Protect internal APIs (health, admin) with access control
- âœ… Validate file uploads (MIME, size)

#### AI Generation Security

AI automatically:

- âœ… Detect and reject insecure patterns (eval, unsafe SQL, unsafe HTML)
- âŒ Never output hardcoded secrets or passwords
- âš ï¸ Warn if user input is directly injected into queries/templates
- âœ… Apply output sanitization in rendered responses
- âœ… Use CSRF token for form submission routes
- âŒ Avoid unbounded recursion or infinite loops

### Error Handling & Logging

- âœ… Global HttpExceptionFilter mandatory
- âœ… Nest Logger or Pino (no console.log in production)
- âœ… Include requestId or traceId in logs
- âŒ Do not leak stack traces in production responses
- âœ… Error payload: `{ statusCode, message, path, timestamp }`

### AI Development Behavior

Before generating backend code:

1. âœ… Scan import and module declarations
2. âœ… Validate circular dependencies; resolve with forwardRef
3. âœ… Auto-add new modules to parent modules
4. âœ… Inject repository/service with DI token, not direct import

**Reject invalid code**:

- âŒ Missing provider registration
- âŒ Unused DTOs/entities
- âŒ Unhandled promise rejections
- âŒ Missing return types

### NestJS Best Practices

- âœ… ConfigModule global + validated with Joi/Zod
- âœ… ValidationPipe: `whitelist + forbidNonWhitelisted + transform: true`
- âœ… ClassSerializerInterceptor for clean responses
- âœ… Each module exports its service for external use
- âœ… Global prefix `/api/v1`
- âœ… All constants in `constants.ts` (no magic strings)
- âœ… Use @nestjs/config and `.env.example`
- âœ… `tsconfig.json`: `module: commonjs` + `moduleResolution: node`
- âŒ Import from main package (`@package`) instead of subpath exports (`@package/subpath`)

### Testing

- **Unit**: Mock dependencies (jest.fn() / vi.fn())
- **E2E**: Supertest + TestingModule
- **Security**: Test unauthorized access returns 401/403
- **Integration**: Test CRUD + transaction rollback
- âœ… All test files must compile and pass lint

---

## ğŸ¨ FRONTEND RULES

### Framework & Stack

- **Framework**: Next.js (App Router)
- **UI Library**: Shadcn/UI + TailwindCSS
- **Architecture**: Feature-driven

```
apps/frontend/
  src/
    app/
    features/
      auth/
      dashboard/
      billing/
    components/
      ui/
      layout/
```

### Feature Structure

Each feature must include:

```
/features/dashboard/
  â”œâ”€â”€ components/
  â”‚     â”œâ”€â”€ DashboardHeader.tsx
  â”‚     â””â”€â”€ StatsCard.tsx
  â”œâ”€â”€ hooks/
  â”‚     â””â”€â”€ useDashboardData.ts
  â”œâ”€â”€ services.ts
  â”œâ”€â”€ types.ts
  â””â”€â”€ index.ts
```

### Component Rules

```typescript
import { Button, Card } from "@/components/ui";
```

- âœ… Always functional components (ES6 syntax)
- âœ… Import Shadcn components from central UI library
- âœ… Server components for data-fetching pages
- âœ… Client components for interactivity
- âœ… Co-locate styles and logic within feature folder
- âŒ Do not use inline styles - use Tailwind utility classes
- âœ… Accessible semantic HTML (main, nav, section, header)
- âŒ No React class components or legacy lifecycle methods

### ğŸ’… Styling & Theming

- **Primary**: TailwindCSS
- **Theme**: Shadcn ThemeProvider (mandatory)
- **Class Order**: layout â†’ spacing â†’ color â†’ typography â†’ state â†’ animation
- âœ… All text WCAG AA color contrast compliant
- âŒ Do not use arbitrary values (px-6 âœ…, px-[26px] âŒ)

### AI Generation Behavior

Generated code:

- âœ… Must compile without lint and type errors
- âœ… TypeScript strict mode compliant
- âœ… Biome lint pass
- âŒ No implicit any, undefined, null (without check)
- âœ… Axios error handling: use `(error as AxiosError<{ message: string }>)`
- âœ… Define optional props in `prop?: Type | undefined` format

**TypeScript Flags**:

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "exactOptionalPropertyTypes": true
  }
}
```

**Auto-fix Required**:

- âŒ Missing types in component props
- âŒ Unused imports/variables
- âŒ Incorrect React.FC usage

### Linting & Formatting (Biome)

- **Config**: biome:recommended
- **Indentation**: 2 spaces
- **Semicolons**: âœ… mandatory
- **Quotes**: single quotes
- **Import Order**: React â†’ third-party â†’ internal (@/)
- âœ… AI must auto-fix common lint issues
- âŒ Do not use unnecessary eslint-disable comments
- âœ… Prefer named exports (instead of default exports)
- âŒ Extract named handlers instead of long inline functions

### Testing

- **Framework**: React Testing Library + Jest
- âœ… Main component render test for each feature
- âŒ Do not use snapshot testing for dynamic UI
- **Mocks**: Use vi.fn() or jest.fn() consistently

### Performance & Best Practices

- âœ… Lazy load heavy components with `dynamic()`
- âœ… Use `React.memo` for expensive re-renders
- âœ… Static rendering (SSG) when possible
- âŒ Do not data fetch in client components unless absolutely necessary
- âœ… Always wrap fetch calls with error boundaries

---

## ğŸ¯ AI GENERAL BEHAVIOR

### When Generating Code

1. âœ… Check existing code, follow patterns
2. âœ… Generate TypeScript strict mode + Biome compliant code
3. âœ… Auto-detect and reject security vulnerabilities
4. âœ… Follow SOLID, DRY, KISS principles
5. âœ… Write testable, modular, clean code
6. âŒ Do not use magic strings or hardcoded values
7. âŒ Do not use deprecated or unsafe APIs
8. âŒ Do not over-engineer

### Error Management

1. âœ… Auto-fix all lint errors
2. âœ… Auto-add missing imports
3. âœ… Auto-remove unused code
4. âœ… Fix type errors
5. âš ï¸ Explain issues that cannot be fixed

### Output Format

- âœ… Minimal, incremental edits
- âœ… Clean, readable, well-documented code
- âœ… Cursor-friendly diffs
- âŒ Do not add unnecessary comments or boilerplate

---

## âœ… PRIORITY ORDER

1. **Security** - Never compromise
2. **Type Safety** - TypeScript strict mode mandatory
3. **Code Quality** - SOLID, DRY, KISS
4. **Performance** - Optimized and scalable
5. **Maintainability** - Readable and testable
6. **Documentation** - JSDoc where necessary

---

These rules are **mandatory** and must be applied in all AI code generation processes.
